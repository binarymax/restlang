{"name":"Restlang","tagline":"A markdown inspired language to describe web APIs","body":"<img src=\"https://raw.githubusercontent.com/binarymax/restlang/master/media/logo.png\"> \r\n\r\nA cross-compiling DSL (domain specific language) for building APIs\r\n\r\n## Hello World\r\n\r\n```restlang\r\n/helloworld\r\n\r\nThis API returns a 'Hello World' message!\r\n\r\n#Get\r\n\r\n\t{/controllers/helloworld.Get}\r\n\r\n\t|message string: The text that holds the message\r\n\t\r\n```\r\n\r\n\r\n## Introduction\r\n\r\nRestlang is a markdown-inspired language that is used to generate server route specifications, client libraries, testing scripts, and developer documentation for web based APIs.\r\n\r\nRestlang defines the 'What' and not the 'How' of APIs. \r\n\r\nFor example, you can easily define a Todo list API resource with 50 lines of restlang, and then automatically generate all of the following:\r\n- The API routes for Node/Express \r\n- A jQuery AJAX library to consume the above API\r\n- Integration test scrips for mocha\r\n- Static HTML documentation files\r\n\r\nThe main idea being when an end language target is written, then the end language target works for all APIs defined with Restlang.  Similar to how a markdown parser can target HTML or PDF - once the target is defined it works for all text written in markdown.\r\n\r\nAs of writing, only one parser exists and is in development.  This repository holds the restlang.js parser for Node and JavaScript.\r\n\r\n### Targets\r\n\r\nA Target is an end result output of the Restlang parser coupled with a generator.  Currently only one target generator is supported through Edda [1].\r\n\r\n#### _Framework targets_\r\n\r\nCurrently, only node is supported as a target through Heimdall[2].  Though Heimdall is semi-mature and in production use, support for Restlang->Heimdall is experimental.\r\n\r\nFuture server framework targets in planning are:\r\n- Golang\r\n- PHP\r\n- Openresty\r\n- MVC.NET\r\n\r\n#### _Client targets_\r\n\r\nA nice side effect of having a full parseable API definition, is that client libraries can be generated.  For now, a tool called Bifrost [3] is in development to generate such frameworks, but is not yet ready.\r\n\r\nFuture client targets in planning are:\r\n- iOs\r\n- Android\r\n- jQuery\r\n- Node\r\n- Golang\r\n- .NET\r\n\r\n#### _Testing targets_\r\n\r\nAutomation of Integration Testing is a key goal of Restlang.  Currently only node/mocha is being developed.  See Ragnarok for more information [4]. \r\n\r\nAside from Ragnarok there are no other Testing targets planned.\r\n\r\n#### _Documentation for Humans target_\r\n\r\nThough  mostly human readable in its raw form (again like markdown), a developer documentation target is in the works to generate static documentation HTML.\r\n\r\n## Todo Example\r\n\r\nHere is an example of a Todo list API in Restlang:\r\n\r\n```restlang\r\n/todo: A Todo list CRUD API\r\n\r\n.identity id int64\r\n\r\n#Get: Gets a specific To-Do Item\r\n\r\n\t{../controllers/todo:Entry}\r\n\r\n\t:id int64 required: The ID of the item entry to retrieve\r\n\r\n\t|id int64: The ID of the item\r\n\t|description string: The textual description of the item\r\n\t|donedate datetime: The date/time when the item was marked as done, null otherwise\r\n\t|createdate datetime: The date the item was entered into the system\r\n\t|isdeleted boolean: True if the item has been removed from the list\r\n\r\n#Get: Gets a list of Todo Items for a List\r\n\r\n\t{../controllers/todo:Collection}\r\n\r\n\t?isdone boolean: If true, only return done items, if false only return not done items\r\n\t?all boolean default false: if true, return all items, done or not\r\n\r\n\t|id int64: The ID of the item\r\n\t|description string: The textual description of the item\r\n\t|donedate datetime: The date/time when the item was marked as done, null otherwise\r\n\t|createdate datetime: The date the item was entered into the system\r\n\t|isdeleted boolean: True if the item has been removed from the list\r\n\r\n#Post: Adds a new Todo Item to a List\r\n\r\n\t{../controllers/todo:Add}\r\n\r\n\t@description string required: The textual description of the item\r\n\t@donedate datetime: The date/time when the item was marked as done, null otherwise\r\n\t@createdate datetime: The date the item was entered into the system\r\n\t@redirect string: Redirect to this URL after Add\r\n\t\r\n\t|id int64: The ID of the newly added item\r\n\t|description string: The textual description of the item\r\n\t|donedate datetime: The date/time when the item was marked as done, null otherwise\r\n\t|createdate datetime: The date the item was entered into the system\r\n\r\n#Put: Saves a specific Todo Item\r\n\r\n\t{../controllers/todo:Save}\r\n\r\n\t:id int64 required: The ID of the item entry to save\r\n\r\n\t@description string: The textual description of the item\r\n\t@donedate datetime: The date/time when the item was marked as done, null otherwise\r\n\t@createdate datetime: The date the item was entered into the system\r\n\t@redirect string: Redirect to this URL after Save\t\t\t\t\r\n\r\n\t|id int64: The ID of the saved Todo item\r\n\t|description string: The textual description of the item\r\n\t|donedate datetime: The date/time when the item was marked as done, null otherwise\r\n\t|createdate datetime: The date the item was entered into the system\r\n\r\n#Delete: Marks a specific Todo Item as deleted\r\n\r\n\t{../controllers/todo:Remove}\r\n\r\n\t:id int64 required: The ID of the item entry to remove\r\n\r\n\t|affectedRows: int32: The number of records effected by the removal\r\n\r\n```\r\n\r\n## Websockets\r\n\r\nRestlang also supports websocket receiver and emitter definitions.  Here is an example of a chat websocket API:\r\n\r\n```\r\n>chat\r\n\tThis websocket method accepts a chat message from the client.\r\n\r\n\t@message string:The text that holds the chat message\r\n\r\n<chat\r\n\tThis websocket method broadcasts a chat message to the client.\r\n\r\n\t|message string:The text that holds the chat message\r\n```\r\n\r\n## Documentation\r\n\r\nWriting restlang is easy, but it assumes you have at least a basic understanding of REST APIs and HTTP.  It is meant to be somewhat forgiving and flexible, and geared towards readability and documentation.\r\n\r\nRestlang works by allowing you to declare resources, methods, request parameters, and response output in a human-readable format.  Restlang does not compile to machine language or bytecode - rather it is parsed into an intermediate JSON, and then the JSON can be used to generate any number of targets.\r\n\r\n### Top-down flow\r\n\r\nRestlang is parsed in a top-down flow.  When an entity is declared, it applies to the previous entity the next level up.  For example, a resource has methods, and methods have parameters.  When a method is declared, it applies to the most recently declared resource.  When a parameter is declared, it applies to the most recently declared method.\r\n\r\nRestlang is driven off newlines and symbols, with a couple keywords thrown in.  A line that begins with one of the key symbols (defined below) is treated as the specified entity.  A line that begins with anything other than a symbol is treated as textual description for the most recently defined entity.\r\n\r\n### Symbol Reference\r\n\r\nThis is the complete reference of symbols.  Any line beginning with one of these symbols is treated as specified:\r\n\r\n-\r\n\r\n#### ```/``` (slash resource)\r\n\r\nThe slash is used to define a top-level REST resource.  In our above ToDo example, the resource is defined as ```/todo```.  This means what it sounds like - that a server is expected to serve a resource via HTTP at /todo\r\n\r\n-\r\n\r\n#### ```#``` (hash method)\r\nDefines an HTTP Resource access method.  You can either supply a verb (GET, POST, PUT, DELETE), or one of the Restlang methods (Entry, Collection, Add, Save, Remove).  More on the Restlang specific methods will be discussed later.\r\n\r\n-\r\n\r\n#### ```.``` (dot property)\r\n\r\nThis symbol is context specific.  A dot property can only apply to a resource or method, and must be coupled with one of the following keywords:\r\n\r\n- identity\r\n- parent\r\n- authentication\r\n- mutable\r\n\r\n-\r\n\r\n#### ```{``` (curly controller)\r\n\r\nThe curly is used as a reference point to an external and implementation specific controller to handle the resource.  Since Restlang is only used to define the API details, it is left to the target framework or language to implement how the request is fulfilled.  This is usually only used when generating the source code files for the server implementation.\r\n\r\n_Note_: While not required, it is good format to end the line with a closing curly brace ```}```\r\n\r\n-\r\n\r\n#### ```:``` (route param)\r\n\r\nThe colon param is used as a route parameter.  For example, the ```:id int64 required``` param for the ```/todo``` GET resource, will serve a route that a client can GET at ```/todo/:id/```\r\n\r\n-\r\n\r\n#### ```?``` (query param)\r\n\r\nThe query param is used as a querystring parameter.  For example, the ```?isdone boolean``` param for the ```/todo``` GET resource, will serve a route that a client can GET at ```/todo/?isdone=true```\r\n\r\n-\r\n\r\n#### ```@``` (body param)\r\n\r\nWhen a POST or PUT is sent, the body param is sent with the body of the request.\r\n\r\n-\r\n\r\n#### ```$``` (file param)\r\n\r\nWhen a POST or PUT is sent, the file param is sent as a form attachment with the body of the request.\r\n\r\n-\r\n\r\n#### ```|``` (pipe output)\r\n\r\nPipe output denotes the outgoing response data.\r\n\r\n-\r\n\r\n#### ```>``` (receiver)\r\n\r\nThe greater-than is used to define a top-level Websocket Receiver.  In our above chat example, the receiver is defined as ```>chat```.  This means what it sounds like - that a server is expected to receive a chat event via Websockets at \"chat\"\r\n\r\n-\r\n\r\n#### ```<``` (emitter)\r\n\r\nThe less-than is used to define a top-level Websocket Emitter.  In our above chat example, the emitter is defined as ```<chat```.  This means what it sounds like - that a server is expected to emit a chat event via Websockets as \"chat\"\r\n\r\n-\r\n\r\n### Parameter declarations\r\n\r\nThe route, query, body, file, and pipe parameters all have the same format:\r\n```<symbol><name> <datatype> [required][default <value>]```\r\n\r\nThe symbol is one of the symbols above\r\n\r\nThe datatype is one of the datatypes below\r\n\r\nThe name is a variable type format: /[a-z]\\w*/i\r\n\r\nrequired and default cannot both be declared.  required overrides default.\r\n\r\n- The ```id``` example from Todo Get:\r\n\r\n ```:id int64 required```\r\n\r\n- The ```isdone``` example from Todo Get:\r\n\r\n ```?isdone boolean```\r\n\r\n- The ```all``` example from Todo Get:\r\n\r\n ```?all boolean default false```\r\n\r\n### \r\n\r\n\r\n## Datatypes\r\n\r\nThe datatype system is meant to be extensible, but supports the following defaults:\r\n\r\n - binary\r\n - boolean\r\n - byte\r\n - datetime\r\n - decimal\r\n - double\r\n - single\r\n - float (same as double)\r\n - guid\r\n - int16\r\n - int32\r\n - int64\r\n - int (same as int32)\r\n - number (same as int32)\r\n - sbyte\r\n - string\r\n - text (same as string)\r\n - stringN (where N is any integer greater than 0.  For example ```string255```)\r\n - time\r\n - datetimeoffset\r\n \r\n### Custom datatypes\r\n\r\nIt is possible to extend the type system and define new datatypes to use in the API.\r\n\r\n_coming soon_  \r\n\r\n## Notes\r\n\r\n - [1] Edda can be found at https://github.com/binarymax/edda\r\n - [2] Heimdall can be found at https://github.com/binarymax/heimdall\r\n - [3] Bifrost can be found at https://github.com/binarymax/bifrost\r\n - [4] Ragnarok can be found at https://github.com/binarymax/ragnarok\r\n\r\nRestlang is released under the MIT license.\r\nCopyright Max Irwin, 2014\r\n\r\n##### _made with love by Max Irwin (http://binarymax.com)_","google":"UA-22107593-10","note":"Don't delete this file! It's used internally to help with page regeneration."}